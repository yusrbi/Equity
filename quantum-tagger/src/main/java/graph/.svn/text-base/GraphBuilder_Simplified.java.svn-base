package graph;

import java.io.IOException;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;

import utils.DatabaseAccess;
import annotations.Annotation;
import knowledgebase.Candidate;
import knowledgebase.WeightsCalculator;
import data.Document_;
import data.Table_;
import edu.stanford.nlp.util.Pair;
import graph.Edge.TYPE;

public class GraphBuilder_Simplified {

	private static Double cand_rel_sim_cut_off;

	private static boolean isCohenNormalization = false;
	public static void buildGraph(HashMap<String, Document_> documents, int table_indx, boolean full_graph,
			boolean general_relatedness, boolean initDB) throws SQLException {
		// TODO Auto-generated method stub
		for (Document_ document : documents.values()) {
			buildGraph(document, table_indx, full_graph, general_relatedness, initDB);
		}
	}

	public static Graph buildGraph(Document_ document, int tableID, boolean full, boolean general_relatedness,
			boolean initDB) throws SQLException {
		DatabaseAccess data_access = DatabaseAccess.getDatabaseAccess();
		Table_ table = document.getTable(tableID);

		Map<String, List<Candidate>> all_candidates = new HashMap<String, List<Candidate>>();
		all_candidates.putAll(table.getCandidates());
		all_candidates.putAll(document.getAllCandidates());

		if (initDB)
			data_access.loadDBFor(document.getTable(tableID), all_candidates, general_relatedness);

		if (!full) {
			return buildPartialGraph(document, table, general_relatedness, initDB);
		}
		// add document mentions
		Map<String, List<Annotation>> doc_mentions = document.getMentions();
		List<Candidate> candidates;
		Graph graph = new AdjListsGraph(document.mentionCount() * 2);
		for (String mention : doc_mentions.keySet()) {
			for (Annotation annotation : doc_mentions.get(mention)) {
				candidates = document.getCandidates(mention + "_" + annotation.getUniqueID());
				graph.addMentionNode(mention + "_" + annotation.getUniqueID(), candidates);
			}
		}
		// add table mentions

		Map<String, List<Annotation>> table_mentions = table.getMentions();
		for (String mention : table_mentions.keySet()) {
			for (Annotation annotation : table_mentions.get(mention)) {
				candidates = table.getCandidates(mention + "_" + annotation.getUniqueID());

				graph.addMentionNode(mention + "_" + annotation.getUniqueID(), candidates);
			}
		}

		double similarity = 0.0;
		for (String doc_mention : doc_mentions.keySet()) {
			for (String table_mention : table_mentions.keySet()) {
				similarity = StringUtils.getJaroWinklerDistance(doc_mention, table_mention);
				if (similarity <= 0.9)
					continue;
				for (Annotation table_annotation : table_mentions.get(table_mention)) {
					for (Annotation doc_annotation : doc_mentions.get(doc_mention)) {
						graph.addEdge(table_mention + "_" + table_annotation.getUniqueID(),
								doc_mention + "_" + doc_annotation.getUniqueID(), similarity,
								Edge.TYPE.SIMILAR_SURFACE);
					}
				}

			}
		}
		// check text table mentions similarties

		// Edges between same mentions from text and document are not needed as
		// the 2 (or more) mentions will be represented with the same node
		// CYCLES-PREVENTION The edges between same row entities are not added
		// for now
		// CYCLES-PREVENTION the edges between the same column entities are not
		// added for now
		// CYCLES-PREVENTION the edges between 2 semantic targets in the context
		// are not added for now
		// add edges from header to the column cells
		// weight from category matching and co-occurrences
		// go by the inverted list of mentions in the table

		Map<Pair<Integer, Integer>, List<Pair<String, Annotation>>> annotations_map = table.getInverted_annotations();
		List<Pair<String, Annotation>> header_annotations, cell_annotations, other_cell_annotaions;
		for (int j = 0; j < table.getNcol(); j++) {
			header_annotations = annotations_map.get(new Pair<Integer, Integer>(0, j));
			for (int i = 1; i < table.getNrow(); i++) {
				cell_annotations = annotations_map.get(new Pair<Integer, Integer>(i, j));
				processHeaderToCellEdges(header_annotations, cell_annotations, table, graph, general_relatedness,
						false);
			}
		}

		if (full) { // in case we need to build the full graph and not the
					// Acyclic graph

			// connect mentions based on the table structure
			for (int i = 1; i < table.getNrow(); i++) {
				for (int j = 0; j < table.getNcol(); j++) {
					cell_annotations = annotations_map.get(new Pair<Integer, Integer>(i, j));
					for (int k = j + 1; k < table.getNcol(); k++) {
						// same row
						other_cell_annotaions = annotations_map.get(new Pair<Integer, Integer>(i, k));
						processCellAnnotationsOnSameRow(cell_annotations, other_cell_annotaions, table, graph,
								general_relatedness, false);
					} //

					for (int k = i + 1; k < table.getNrow(); k++) {
						// same column
						other_cell_annotaions = annotations_map.get(new Pair<Integer, Integer>(k, j));
						processCellAnnotationsOnSameColumn(cell_annotations, other_cell_annotaions, table, graph,
								general_relatedness, false);
					}
				}
			}

		}
		graph.normalizeEdgeWeights();

		document.setGraph(graph);
		try {
			document.saveGraph("_full", false);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return graph;
	}

	private static Graph buildPartialGraph(Document_ document, Table_ table, boolean general_relatedness,
			boolean init) {
		Graph compactGraph = new AdjListsGraph(document.mentionCount() * 2);
		// add mentions to the graph and aggregate edge weights
		// add document mentions
		Map<String, List<Annotation>> doc_mentions = document.getMentions();
		Map<String, List<Annotation>> table_mentions = table.getMentions();

		List<Candidate> candidates;
		for (String mention : doc_mentions.keySet()) {
			for (Annotation annotation : doc_mentions.get(mention)) {
				candidates = document.getCandidates(mention + "_" + annotation.getUniqueID());
				compactGraph.addMentionNodeAggregateCandidates(mention + "_" + annotation.getUniqueID(), candidates);
			}
		}
		// add table mentions

		for (String mention : table_mentions.keySet()) {
			for (Annotation annotation : table_mentions.get(mention)) {
				candidates = table.getCandidates(mention + "_" + annotation.getUniqueID());

				compactGraph.addMentionNodeAggregateCandidates(mention + "_" + annotation.getUniqueID(), candidates);
			}
		}

		double similarity = 0.0;
		for (String doc_mention : doc_mentions.keySet()) {
			for (String table_mention : table_mentions.keySet()) {
				similarity = StringUtils.getJaroWinklerDistance(doc_mention, table_mention);
				if (similarity <= 0.9)
					continue;
				for (Annotation table_annotation : table_mentions.get(table_mention)) {
					for (Annotation doc_annotation : doc_mentions.get(doc_mention)) {
						compactGraph.addPotentialEdge(table_mention + "_" + table_annotation.getUniqueID(),
								doc_mention + "_" + doc_annotation.getUniqueID(), similarity,
								Edge.TYPE.SIMILAR_SURFACE);
					}
				}

			}
		}

		Map<Pair<Integer, Integer>, List<Pair<String, Annotation>>> annotations_map = table.getInverted_annotations();
		List<Pair<String, Annotation>> header_annotations, cell_annotations, other_cell_annotaions;
		for (int j = 0; j < table.getNcol(); j++) {
			header_annotations = annotations_map.get(new Pair<Integer, Integer>(0, j));
			for (int i = 1; i < table.getNrow(); i++) {
				cell_annotations = annotations_map.get(new Pair<Integer, Integer>(i, j));
				processHeaderToCellEdges(header_annotations, cell_annotations, table, compactGraph, general_relatedness,
						true);
			}
		}

		// mention-mention based on table structure
		// connect mentions based on the table structure
		for (int i = 1; i < table.getNrow(); i++) {
			for (int j = 0; j < table.getNcol(); j++) {
				cell_annotations = annotations_map.get(new Pair<Integer, Integer>(i, j));
				for (int k = j + 1; k < table.getNcol(); k++) {
					// same row
					other_cell_annotaions = annotations_map.get(new Pair<Integer, Integer>(i, k));
					processCellAnnotationsOnSameRow(cell_annotations, other_cell_annotaions, table, compactGraph,
							general_relatedness, true);
				} //

				for (int k = i + 1; k < table.getNrow(); k++) {
					// same column
					other_cell_annotaions = annotations_map.get(new Pair<Integer, Integer>(k, j));
					processCellAnnotationsOnSameColumn(cell_annotations, other_cell_annotaions, table, compactGraph,
							general_relatedness, true);
				}
			}
		}
		
		//TODO -->change this 

		double sim = 0.0;
		double aggregated_sim = 0;
		String mention1, mention2;
		Map<String, List<Candidate>> all_candidates = new HashMap<String, List<Candidate>>();
		all_candidates.putAll(table.getCandidates());
		all_candidates.putAll(document.getAllCandidates());
		Set<String> done = new LinkedHashSet<String>(document.mentionCount());

		for (Entry<String, List<Candidate>> entry : all_candidates.entrySet()) {
			// prepare candidates
			for (Entry<String, List<Candidate>> entry2 : all_candidates.entrySet()) {
				if (done.contains(entry.getKey() + entry2.getKey()) || done.contains(entry2.getKey() + entry.getKey()))
					continue;
				mention1 = entry.getKey().split("_")[0];
				mention2 = entry2.getKey().split("_")[0];
				if (mention1.equals(mention2))
					continue;
				for (Candidate cand : entry.getValue()) {
					// prepare candidates
					for (Candidate cand2 : entry2.getValue()) {
						// if (cand.equals(cand2))
						// continue;
						if (done.contains(cand.getSemanticTargetIdForGraph() + cand2.getSemanticTargetIdForGraph())
								|| done.contains(
										cand2.getSemanticTargetIdForGraph() + cand.getSemanticTargetIdForGraph()))
							continue;
						sim = WeightsCalculator.getCandCandSimilarity(cand, cand2);
						if (sim > 0) {
							compactGraph.addCandidateCandidateEdgeWeight(cand.getSemanticTargetIdForGraph(),
									cand2.getSemanticTargetIdForGraph(), sim);
							aggregated_sim += sim;
						}
						done.add(cand.getSemanticTargetIdForGraph() + cand2.getSemanticTargetIdForGraph());
					}
				}
				// add an aggregated edge
				if (aggregated_sim > 0)
					compactGraph.addPotentialEdge(entry.getKey() + "_cand", entry2.getKey() + "_cand", aggregated_sim,
							TYPE.CANDIDATE_CANDIDATE);
				aggregated_sim = 0.0;
				done.add(entry.getKey() + entry2.getKey());
			}
		}

		compactGraph.removeCycles();
		compactGraph.expandEdges();
		
		if(isCohenNormalization)
			compactGraph.normalizeEdgeWeightsByConstant();
		else
			compactGraph.normalizeEdgeWeights();

		document.setGraph(compactGraph);
		try {
			if (init)
				document.saveGraph("_partial", false);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return compactGraph;

	}	

	public static void setCohenNormalization(boolean isCohenNormalization) {
		GraphBuilder_Simplified.isCohenNormalization = isCohenNormalization;
	}

	private static void processHeaderToCellEdges(List<Pair<String, Annotation>> header_annotations,
			List<Pair<String, Annotation>> cell_annotations, Table_ table, Graph graph, boolean general_relatedness,
			boolean addPotentialEdge) {
		if (header_annotations == null || cell_annotations == null) {
			return;
		}
		String header_id, cell_id;
		List<Candidate> header_candidates, cell_candidates;
		double sim;
		for (Pair<String, Annotation> header_annotaion : header_annotations) {
			header_id = header_annotaion.first + "_" + header_annotaion.second.getUniqueID();
			header_candidates =table.getCandidates(header_id);
			for (Pair<String, Annotation> cell_annotaion : cell_annotations) {
				cell_id = cell_annotaion.first + "_" + cell_annotaion.second.getUniqueID();
				cell_candidates = table.getCandidates(cell_id);				
				if (header_candidates == null || cell_candidates == null) {
					continue;
				}
				for (Candidate header_candidate : header_candidates) {
					for (Candidate cell_candidate : cell_candidates) {
						sim = WeightsCalculator.getHeaderCellCandidatesSimilarity(header_candidate, cell_candidate,
								general_relatedness);
						//if (sim > cand_rel_sim_cut_off)
						if (addPotentialEdge)
							graph.addEdge(header_candidate.getSemanticTargetIdForGraph(),
									cell_candidate.getSemanticTargetIdForGraph(), sim, Edge.TYPE.HEADER_CELL);
						else
							graph.addEdge(header_candidate.getSemanticTargetIdForGraph(),
									cell_candidate.getSemanticTargetIdForGraph(), sim, Edge.TYPE.HEADER_CELL);
					}

				}
				 
			}

		}

	}

	public static void setCandRelSimCutOff(Double val) {

		cand_rel_sim_cut_off = val;
	}

	private static void processCellAnnotationsOnSameColumn(List<Pair<String, Annotation>> cell_annotations,
			List<Pair<String, Annotation>> other_cell_annotaions, Table_ table, Graph graph,
			boolean general_relatedness, boolean addPotentialEdge) {
		if (other_cell_annotaions == null || cell_annotations == null) {
			return;
		}
		List<Candidate> cell_candidates, other_cell_candidates;
		String cell_id, other_id;
		double sim = 0.0;
		for (Pair<String, Annotation> cell_annotaion : cell_annotations) {
			cell_id = cell_annotaion.first + "_" + cell_annotaion.second.getUniqueID();
			cell_candidates = table.getCandidates(cell_id);
			for (Pair<String, Annotation> other_cell_annotaion : other_cell_annotaions) {
				// check for all the candidates
				other_id = other_cell_annotaion.first + "_" + other_cell_annotaion.second.getUniqueID();
				other_cell_candidates = table.getCandidates(other_id); 
				if (cell_candidates == null || other_cell_candidates == null) {
					continue;
				}
				for (Candidate cell_candidate : cell_candidates) {
					for (Candidate other_cell_candidate : other_cell_candidates) {
						sim = WeightsCalculator.getSameColumnSimilarity(cell_candidate, other_cell_candidate,
								general_relatedness);
						// if (sim > cand_rel_sim_cut_off)
						if (addPotentialEdge)
							graph.addPotentialEdge(cell_candidate.getSemanticTargetIdForGraph(),
									other_cell_candidate.getSemanticTargetIdForGraph(), sim, Edge.TYPE.SAME_COLUMN);
						else
							graph.addEdge(cell_candidate.getSemanticTargetIdForGraph(),
								other_cell_candidate.getSemanticTargetIdForGraph(), sim, Edge.TYPE.SAME_COLUMN);
					}

				}
			}

		}

	}

	private static void processCellAnnotationsOnSameRow(List<Pair<String, Annotation>> cell_annotations,
			List<Pair<String, Annotation>> other_cell_annotaions, Table_ table, Graph graph,
			boolean general_relatedness, boolean addPotentialEdge) {
		if (other_cell_annotaions == null || cell_annotations == null) {
			return;
		}
		List<Candidate> cell_candidates, other_cell_candidates;
		String cell_id, other_id;
		double sim = 0.0;
		for (Pair<String, Annotation> cell_annotaion : cell_annotations) {
			cell_id = cell_annotaion.first + "_" + cell_annotaion.second.getUniqueID();
			cell_candidates = table.getCandidates(cell_id);
			for (Pair<String, Annotation> other_cell_annotaion : other_cell_annotaions) {
				other_id = other_cell_annotaion.first + "_" + other_cell_annotaion.second.getUniqueID();
				// check for all the candidates
				other_cell_candidates = table.getCandidates(other_id);
				if (cell_candidates == null || other_cell_candidates == null) {
					continue;
				}
				for (Candidate cell_candidate : cell_candidates) {
					for (Candidate other_cell_candidate : other_cell_candidates) {
						sim = WeightsCalculator.getSameRowSimilarity(cell_candidate, other_cell_candidate,
								general_relatedness);
						if (addPotentialEdge)
							graph.addPotentialEdge(cell_candidate.getSemanticTargetIdForGraph(),
									other_cell_candidate.getSemanticTargetIdForGraph(), sim, Edge.TYPE.SAME_ROW);
						else
							graph.addEdge(cell_candidate.getSemanticTargetIdForGraph(),
								other_cell_candidate.getSemanticTargetIdForGraph(), sim, Edge.TYPE.SAME_ROW);
					}

				}
			}

		}
	}
}
